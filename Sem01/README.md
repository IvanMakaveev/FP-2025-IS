# Семинар №1 - Въведение във Функционалното Програмиране. Синтаксис. Декларации и дефиниции на функции.  

## Кратък увод
Преди да започнем да говорим за функционално програмиране е добре да разгледаме следните две парадигми в "света на програмирането".

**Императивен Стил на програмиране** - Вид парадигма (модел на мислене/методика) в програмирането на софтуер, която се базира на поредица от изрази, променящи състоянието на програмата. Името произлиза от "заповедната" форма на иструкциите - описва се точно какво трябва да се извърши стъпка по стъпка. Редът на операциите най-често се определя чрез номерация на инструкциите и използване на goto оператор (или конструкции, които скрито го използват, като if, while и for блокове) или чрез използване на структуриран подход (чрез индентации като в Python)

Пример за Императивен Стил е **Обектно-Ориентираното Програмиране**, което разглеждаме в курсовете по УП и ООП.

В този курс ще насочим вниманието си към друга парадигма, която често се нарича "противоположност" на императивния стил. Това е така наречения Декларативен Стил.

**Декларативен Стил на програмиране** - Вид парадигма в програмирането на софтуер, в която се описват свойствата на желания резултат. Построява се структурата на програмата, която отразява логиката зад изчисленията, без да се описва "control flow" (поток на управление)

Преди да продължим, има един важен въпрос - Защо ни е?

Понякога е по-лесно да поискаме свойства/ограничения върху резултата, отколкото да пишем дълги и сложни алгоритми. Най-често се прилага, когато не търсим оптималност, а по-голяма експресивност на записа. Разбира се, това не означава, че не може да се пише оптимално с този стил. Много от съвременните императивни езици не случайно поддържат или въвеждат допълнително функционални възможности (например - C# LINQ; Java Stream API и др). Все пак някои базови операции (примитиви) се налагат, за да има смисъл в операциите. Начинът, по който те се изпълняват зависи вече от съответния език.

**Примери за Декларативен Стил чрез задача за намиране на GCD:**
1) **Constraint Programming (CP)** - Програмиране с ограничения \
Дадени са a и b \
Търсим d такова че:  
1: d дели а \
2: d дели b \
3: d е възможно най-голямо
2) **Logical Programming (LP)** - Логическо Програмиране \
TODO: Add example...
3) **Functional Programming (FP)** - Функционално програмиране \
Дефинириаме функция gcd(a, b) над естествените числа със свойства: \
gcd(a, a) = a \
За a > b gcd(a, b) = gcd(a - b, b) \
За a < b gcd(a, b) = gcd(a, b - a) \
При дадени x и y да се пресметне gcd(x, y)

## Малко теория за функциите в математиката и програмирането (допълнителен материал)
За да разберем какво точно можем да правим с *функционално* програмиране е добре да започнем от там какво е функция.

**Функция** - вид релация, при която всеки елемент от domain-а се съпоставя с най-много един елемент от codomain-а.

(**Extra**) Обаче остава въпросът дали всяка функция може да се представи под формата на код, който ние пишем. Ами, за жалост отговорът е "не". Може да се покаже, че използваните в практиката езици от Императивния и Декларативния стил са равномощни на модела на **Машината на Тюринг**. Тъй като произволна машина на Тюринг може да се кодира като естествено число, това означава, че те са *краен брой*. Функциите от вида f: N -> N би трябвало да сме запознати, че са неизброимо множество. Следователно само малка част от тях можем да представим с нашите програми. Това са така наречените **изчислими функции**.

(**Extra**) Има изчислими функции, за които нямаме конструктивен вид. Пример: "f(n) - пресмята дали има n последователни 7ци в числото Pi". Числото PI е изчислимо, откъдето може да се покаже, че и тази функция е изчислима. Проблемът е, че доказателството за тази функция не е конструктивно - тоест не я построяваме, а показваме, че няма как да не е изчислима. Но все пак не я знаем коя е. В този курс ще работим само с **конструктивни функции**.

Полезно следствие, което е важно да се запомни е, че езиците от Императивният и Декларативният стил са еднакво мощни. Тоест - програма написана на език от едната парадигма може да се напише и на другата (просто може да е по-трудно на едната, отколкото на другата, но не невъзможно).

## Въведение в Haskell
Преди да се запознаем подробно със синтаксиса на езика, ще отбележим някои важни негови свойства:

1) Статично типизиран
2) Чист откъм странични ефекти
3) Използва лениво оценяване (lazy evaluation)

В следствие на строгата си статична типизираност, езикът има мощна типова система, която често сама може да се ориентира какви типове ни трябват. В рамките на този курс обаче ще се стремим максимално често ние сами да пишем типовете, за да разберем кое, как и защо работи.

### Синтаксис
Имената на "обектите" в Haskell се наричат **идентификатори**. Те са последователност от букви, цифри, долни черти, като важно условие е, че започват задължително с малка буква или долна черта.

**Примери:** fact, fib, _myVar...

Има запазени идентификатори, с които ще се сблъскаме, като: let, if, case, where...

**Конструктори** ще наричаме идентификатори, които започват с главна буква. С тях ще се запознаем по-нататък в курса.

**Примери:** Integer, Maybe, Just, True, False...

**Числа:** 15, -5, 2.34, 4.1е-3...

**Оператори/Операции** ще наричаме последователност от символи, които не са букви и цифри. По-надолу в този документ ще разберем повече за тях.

**Примери:** +, *, $=>, ♣♠♦...

Има и някои запазени операции в езика, като например .. : :: = <- -> и други.

**Знаците** в Haskell се бележат подобно на ситаксиса им в C++, като се отделят с единични кавички. Могат да се екранират символи, като например символът за нов ред '\n', чрез употребата на обратна наколонена черта отпред.

### Декларации и Дефиниции
Декларация означава на даден идентификатор да зададем точно какъв тип данни очаква. Те често не са задължителни, защото Haskell има мощна типова система, но в рамките на този курс ще ги пишем. Задават се по следният начин:

<име> :: <тип>

Този запис означава, че <име> ще се **свързва** със стойности от дадения <тип>.

```haskell
myNumber :: Integer
isValid :: Bool
```

Дефинициите задават с какъв израз да се **свърже** даден идентификатор. Свързването означава, че под този идентификатор "ще се разбира" зададения израз. Записва се по следният начин:

<име> = <израз>

Казваме, че <име> се свързва с <израз>. Важно е да отбележим, че изразът трябва да е от тип, съответен на зададения при декларацията на името. Също така е важно да отбележим, че това не е присвояване като в C++. Тук не се пресмята израза и резултата му да се записва в някаква променлива! Името е свързано със самия израз, а не с резултата му! (Повече за това на темата за мързеливо оценяване)

```haskell
myNumber = 42 + 17
isValid = True && odd myNumber
```

### Основни Типове
За да можем да правим декларации е редно да се запознаем и с някои типове. Типовете се задават с помощта на конструктори. За момента ще разгледаме слендите:

* Bool - булев тип с възможни стойности True и False
  * Няма имплицитен casting от числа в стойностите True или False!
* Char - представляват Unicode знаци
* Целочислени типове:
  * Int - ограничен целочислен тип в диапазона [-2^63; 2^63 - 1]
  * Integer - неограничен целочислен тип
* Числа с плаваща запетая:
  * Float - с единична точност
  * Double - с двойна точност
* Съставни типове
  * [a] - тип списък с **произволна дължина** и **елементи от фиксиран тип** а
  * (a, b, c) - тип кортеж (n-торка/tuple) с **фиксирана дължина** (в случая наредена 3-ка) и **елементи от произволни типове a, b и c**

### Стандартни числови функции
Аритметични операции: + - * / ^ ^^

Други функции: div, mod, max, min, gcd, lcm

Функции за преобразуване: fromIntegral, fromInteger, toInteger, realToFrac, fromRational, toRational, ceiling, floor, round

```haskell
x :: Int
x = 5

y :: Double
y = fromIntegral x ^ 2 + 7.5
```

Функции за дробни числа: exp, log, sin, cos, tan, **

### Стандартни предикати
Числови предикати: > < == /= even odd

Булеви операции: || && not

```haskell
isValid :: Bool
isValid = even 5 || (7 > 2)
```

### Функции - синтаксис
Щом говорим за функционално програмиране, може би най-важното нещо е да разберем как се създават функции.

Функция се **декларира** посредством следният синтаксис:

<име> :: t1 -> t2

Този запис ни казва, че декларираме функция с <име>, която приема стойност (формален параметър) от тип t1 и ни връща резултат от тип t2.

Функция се **дефинира** както следва:

<име> <параметър> = <тяло>

Съответно **прилагаме** функцията, като я извикаме с конкретна стойност или израз за параметъра (фактически параметър):

<име> <израз>

Обръщаме внимание, че прилагането не се нуждае от ограждане със скоби. Също така то е с по-висок приоритет от операциите. Пример за това е:

```haskell
square 2 + 3
-- Result: (2 * 2) + 3 = 7
```

### Функции с повече параметри - Currying
Видяхме как се представят функции с един аргумент. Как обаче да запишем функция на повече аргументи?

Нека разгледаме функцията f(x, y) = z. Можем да я представим по следният начин:
* f(x) = f_x - функция, която приема един аргумент и ни връща функция
* f_x(y) = z

Тоест, можем да предсатвим функция на n аргумента като функция, която приема един аргумент и ни връща функция на n - 1 аргумента. Това представяне на функциите се нарична **Currying**.

Функция на два аргумента съответно записваме:

<име> :: t1 -> (t2 -> t3)

Четем: <име> ще се свързва с функция, приемаща аргумент от тип t1 и връщаща друга функция, която приема параметър от тип t2 и връща резултат от тип t3.

За функция на n аргумента съответно имаме:

<име> :: t1 -> t2 -> ... -> tn -> tres

Имаме и следният syntax sugar за дефиниция на функция на n аргумента:

<име> \<param1> \<param2> ... \<paramn> = <тяло>

### Частично прилагане
Тъй като от предсатвянето на функции чрез Currying, всяка функция на повече аргументи реално е функция на един аргумент, връщаща друга функция, можем да приложим основната функция частично.

Тоест - можем да подадем само част от фактическите параметри и да получим функция, която на по-късен етап да получи останалите.

**Пример:**
```haskell
-- Function that takes a number and returns 50 divided by that number
divide50 = div 50
```

### Функции VS Операции
Операциите в Haskell са обикновени **двуместни функции**, които ни позволяват да използваме **инфиксен запис**, вместо префиксен.

Можем да използваме произволна операция (ще я отбележа с !$>) с префиксен запис по следният начин:

(!$>) <параметър1> <параметър2>

**Пример:**
```haskell
(+) 2 3
-- Result: 5
```

Можем да извикаме и произволна *двуместна* функция като оператор (с инфиксен запис):

<параметър1> \`<функция>\` <параметър2>

**Пример:**
```haskell
3 `div` 2
-- Result: 1
```

**Бележка:** Има точно едно изключение от правилото и това е **унарния минус**. Символът за минус в зависимост от контекста може да е изваждане или унарен минус за отрицателно число и трябва да се внимава!

### Условни изрази
if <израз1> then <израз2> else <израз3>

Този израз първо изчислява <израз1>, който е задължително от тип Bool. Ако е истина (True) ще се изчисли до <израз2>, а в противен случай - до <израз3>. Изразите <израз2> и <израз3> трябва задължително да са от един тип!

Важно нещо, което трябва да отбележим е, че тук if не е конструкция, а е **израз**. **Тоест се изчислява до даден резултат с даден тип!** Не използва преходи от типа на goto, както в императивния стил.

```haskell
abs :: Integer -> Integer
abs x = if x > 0 then x else -x
```

### Разглеждане на случаи
Посредством **guards** (пазачи) можем да разглеждаме случаи.

<име> <параметри>
    | <условие1> = <израз1>
    | <условие2> = <израз2>
    ...
    | otherwise = <изразn>

След заместване на формалните параметри с фактическите, последователно се проверява всяко условие от <условие1> натам. Първото срещнато <условиеi> със стойност True връща като стойност съответния израз <изразi>. 

Otherwise е синоним на True, предназначен за употреба в guard-ове.

Ако не се срещне стойност True се извежда грешка.

**Пример:**
```haskell
fact :: Integer -> Integer
fact n
    | n == 0 = 1
    | n > 0 = n * fact (n - 1)
    | otherwise = error "Error message"
```

### Локални дефиниции с let
Локалните дефиниции представляват помощни "твърдения", които използваме в тялото на функцията.

let
    <дефиниция1>
    <дефиниция2>
    ...
in <тяло>

Дефинициите може да са взаимно рекурсивни (тоест да зависят една от друга).

Също така, може да използваме let без тяло в интерпретатора, за да въвеждаме нови дефиниции.

### Локални дефиниции с where
Локалните дефиниции с where се задават по следния начин:

<дефиниция на ф-я>
    where <дефиниция 1>
          <дефиниция 2>
          ...

Те отново може да са взаимно рекурсивни.

### Сравнение на Let и Where
На пръв поглед let и where правят едно и също, но те имат не малко разлики.

Като за начало - let е израз, което означава, че може да се използва навсякъде, където може и израз, докато where може да се използва само като част от дефиниция на функция.

Друга разлика е твоа, че where дефинициите са видими навсякъде в основната дефиниция на функцията (включително в случаите на всеки от guard-овете, ако има такива), докато let дефинициите не са.

Те имат и стилистична разлика - where дефинициите са част от основното твърдение (помощна дефиниция, използвана в условието на задачата), докато let са допускания, които ние сме направили за улеснение (помощна дефиниция, използвана в решението на задачата).

**Забележка:** подравняването в синтаксиса на guard-овете, let и where е от значение!

**Примери:**
```haskell
myGcd :: Int -> Int -> Int
myGcd a b
    | a == b = a
    | a > b = myGcd (a - b) b
    | otherwise = myGcd a (b - a)

countQuadraticRoots :: Double -> Double -> Double -> Int
countQuadraticRoots a b c
    | disc < 0 = 0
    | disc == 0 = 1
    | otherwise = 2
    where disc = b ^ 2 - 4 * a * c
```